package com.dahuangit.seobi.proxy.service.impl;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import com.dahuangit.base.dto.opm.response.PageQueryResult;
import com.dahuangit.base.exception.GenericException;
import com.dahuangit.seobi.proxy.dao.ProxyDao;
import com.dahuangit.seobi.proxy.dto.opm.response.ProxyResponse;
import com.dahuangit.seobi.proxy.entry.Proxy;
import com.dahuangit.seobi.proxy.service.ProxyJobService;
import com.dahuangit.seobi.proxy.service.ProxyService;
import com.dahuangit.util.date.DateUtils;
import com.dahuangit.util.log.Log4jUtils;
import com.dahuangit.util.net.TelnetUtils;
import com.dahuangit.util.net.http.HostInfo;
import com.dahuangit.util.net.http.HttpHeaderInfo;
import com.dahuangit.util.net.http.HttpKit;

@Component
@Transactional
public class ProxyServiceImpl implements ProxyService {

	private static final Logger log = Log4jUtils.getLogger(ProxyServiceImpl.class);

	@Autowired
	private ProxyDao proxyDao = null;

	@Autowired
	private ProxyJobService proxyJobService = null;

	/**
	 * 批量导入代理服务器信息
	 * 
	 * @param multipartFile
	 * @throws IOException
	 */
	public void impProxy(MultipartFile multipartFile) throws IOException {
		byte[] btArr = multipartFile.getBytes();

		ByteArrayInputStream bis = new ByteArrayInputStream(btArr);
		InputStreamReader isr = new InputStreamReader(bis);

		BufferedReader br = new BufferedReader(isr);

		String line = null;
		List<Proxy> proxies = new ArrayList<Proxy>();

		while (null != (line = br.readLine())) {
			String[] proxyInfo = line.split(":");
			if (proxyInfo.length != 2) {
				log.info("已跳过到不符合格式的代理信息行:" + line);
				continue;
			}

			String proxyIp = proxyInfo[0].trim();
			int proxyPort = 0;
			try {
				proxyPort = Integer.parseInt(proxyInfo[1].trim());
				continue;
			} catch (NumberFormatException e) {
				log.info("已跳过端口不合法的代理信息行:" + line);
			}

			//通过ip和端口进行查询，如果不存在
			
			Proxy proxy = new Proxy();
			proxy.setProxyIp(proxyIp);
			proxy.setProxyPort(proxyPort);

			proxies.add(proxy);
		}

		this.proxyDao.batchAdd(proxies);

		// 启动线程开始检查这些服务器是否可用
		new Thread() {

			@Override
			public void run() {
				proxyJobService.checkAndSetProxyStatus();
			}

		}.start();
	}

	/**
	 * 通过代理进行http请求<br>
	 * 
	 * @return
	 * @throws IOException
	 */
	public String doRequestByProxy(HttpHeaderInfo headerInfo) throws IOException {
		List<Proxy> proxyList = this.proxyDao.getAvailateProxyOrderByLastTestTime();

		Proxy proxy = null;

		for (Proxy p : proxyList) {
			boolean available = TelnetUtils.isAvailableServer(p.getProxyIp(), p.getProxyPort(), 5 * 1000);
			if (available) {
				proxy = p;
				break;
			}
		}

		if (null == proxy) {
			throw new GenericException("无法找到可用的代理服务器，请确认当前是否有代理服务器列表是否为空");
		}

		String url = headerInfo.getHost();
		String method = headerInfo.getMethod();

		log.info("正在通过代理进行http请求...");
		log.info("地址=" + url);
		log.info("代理IP=" + proxy.getProxyIp());
		log.info("代理端口=" + proxy.getProxyPort());

		HostInfo proxyHost = new HostInfo();
		proxyHost.setAddr(proxy.getProxyIp());
		proxyHost.setPort(proxy.getProxyPort());

		String content = null;

		if ("GET".equalsIgnoreCase(method)) {
			content = HttpKit.doGetByProxy(url, proxyHost, headerInfo.getHeaders());
		} else if ("POST".equalsIgnoreCase(method)) {
			content = HttpKit.doPostByProxy(url, proxyHost, null, headerInfo.getHeaders());
		} else {
			throw new GenericException("非法的http方法：" + method);
		}

		log.info("返回内容=" + content);

		// 更新代理的最后通信时间
		proxy.setLastTestTime(new Date());
		this.proxyDao.update(proxy);

		StringBuffer sb = new StringBuffer();
		sb.append("HTTP/1.1 200 OK");
		sb.append("\r");
		sb.append("\n");
		sb.append("Server: Apache-Coyote/1.1");
		sb.append("\r");
		sb.append("\n");
		sb.append("Accept-Charset: big5, big5-hkscs, euc-jp, euc-kr, gb18030, gb2312, gbk, ibm-thai, ibm00858, ibm01140, ibm01141, ibm01142, ibm01143, ibm01144, ibm01145, ibm01146, ibm01147, ibm01148, ibm01149, ibm037, ibm1026, ibm1047, ibm273, ibm277, ibm278, ibm280, ibm284, ibm285, ibm297, ibm420, ibm424, ibm437, ibm500, ibm775, ibm850, ibm852, ibm855, ibm857, ibm860, ibm861, ibm862, ibm863, ibm864, ibm865, ibm866, ibm868, ibm869, ibm870, ibm871, ibm918, iso-2022-cn, iso-2022-jp, iso-2022-jp-2, iso-2022-kr, iso-8859-1, iso-8859-13, iso-8859-15, iso-8859-2, iso-8859-3, iso-8859-4, iso-8859-5, iso-8859-6, iso-8859-7, iso-8859-8, iso-8859-9, jis_x0201, jis_x0212-1990, koi8-r, koi8-u, shift_jis, tis-620, us-ascii, utf-16, utf-16be, utf-16le, utf-32, utf-32be, utf-32le, utf-8, windows-1250, windows-1251, windows-1252, windows-1253, windows-1254, windows-1255, windows-1256, windows-1257, windows-1258, windows-31j, x-big5-solaris, x-euc-jp-linux, x-euc-tw, x-eucjp-open, x-ibm1006, x-ibm1025, x-ibm1046, x-ibm1097, x-ibm1098, x-ibm1112, x-ibm1122, x-ibm1123, x-ibm1124, x-ibm1381, x-ibm1383, x-ibm33722, x-ibm737, x-ibm834, x-ibm856, x-ibm874, x-ibm875, x-ibm921, x-ibm922, x-ibm930, x-ibm933, x-ibm935, x-ibm937, x-ibm939, x-ibm942, x-ibm942c, x-ibm943, x-ibm943c, x-ibm948, x-ibm949, x-ibm949c, x-ibm950, x-ibm964, x-ibm970, x-iscii91, x-iso-2022-cn-cns, x-iso-2022-cn-gb, x-iso-8859-11, x-jis0208, x-jisautodetect, x-johab, x-macarabic, x-maccentraleurope, x-maccroatian, x-maccyrillic, x-macdingbat, x-macgreek, x-machebrew, x-maciceland, x-macroman, x-macromania, x-macsymbol, x-macthai, x-macturkish, x-macukraine, x-ms950-hkscs, x-mswin-936, x-pck, x-utf-16le-bom, x-utf-32be-bom, x-utf-32le-bom, x-windows-50220, x-windows-50221, x-windows-874, x-windows-949, x-windows-950, x-windows-iso2022jp");
		sb.append("\r");
		sb.append("\n");
		sb.append("Content-Type: text/plain;charset=ISO-8859-1");
		sb.append("\r");
		sb.append("\n");
		sb.append(content);

		return sb.toString();
	}

	/**
	 * 通过代理进行http请求<br>
	 * 
	 * @param url
	 * @return
	 * @throws IOException
	 */
	public String doRequestByProxy(String url, String encode, String method) throws IOException {
		List<Proxy> proxyList = this.proxyDao.getAvailateProxyOrderByLastTestTime();

		Proxy proxy = null;

		for (Proxy p : proxyList) {
			boolean available = TelnetUtils.isAvailableServer(p.getProxyIp(), p.getProxyPort(), 5 * 1000);
			if (available) {
				proxy = p;
				break;
			}
		}

		if (null == proxy) {
			throw new GenericException("无法找到可用的代理服务器，请确认当前是否有代理服务器列表是否为空");
		}

		log.info("正在通过代理进行http请求...");
		log.info("地址=" + url);
		log.info("编码=" + encode);
		log.info("代理IP=" + proxy.getProxyIp());
		log.info("代理端口=" + proxy.getProxyPort());

		HostInfo proxyHost = new HostInfo();
		proxyHost.setAddr(proxy.getProxyIp());
		proxyHost.setPort(proxy.getProxyPort());
		proxyHost.setEncode(encode);

		String content = null;

		if ("GET".equalsIgnoreCase(method)) {
			content = HttpKit.doGetByProxy(url, proxyHost, null);
		} else if ("POST".equalsIgnoreCase(method)) {
			content = HttpKit.doPostByProxy(url, proxyHost, null, null);
		} else {
			throw new GenericException("非法的http方法：" + method);
		}

		log.info("返回内容=" + content);

		// 更新代理的最后通信时间
		proxy.setLastTestTime(new Date());
		this.proxyDao.update(proxy);

		return content;
	}

	public void deleteProxy(Integer id) {
		Proxy proxy = new Proxy();
		proxy.setPid(id);
		this.proxyDao.delete(proxy);

	}

	@Override
	public PageQueryResult<ProxyResponse> findByPage(Integer start, Integer limit) {
		String listHql = "from Proxy p order by p.lastTestTime desc";
		String countHql = "select count(*)  from Proxy";

		PageQueryResult<ProxyResponse> pageQueryResult = new PageQueryResult<ProxyResponse>();

		List<Proxy> rows = this.proxyDao.findByPage(listHql, start, limit);

		List<ProxyResponse> results = new ArrayList<ProxyResponse>();

		for (Proxy proxy : rows) {
			ProxyResponse pr = new ProxyResponse();
			pr.setPid(proxy.getPid());

			boolean isAvailable = proxy.getAvailable();
			if (isAvailable) {
				pr.setAvailable("是");
			} else {
				pr.setAvailable("否");
			}

			pr.setLastTestTime(DateUtils.format(proxy.getLastTestTime()));

			pr.setProtocol(proxy.getProtocol());
			pr.setProxyIp(proxy.getProxyIp());
			pr.setProxyPort(proxy.getProxyPort());
			pr.setRemark(proxy.getRemark());

			results.add(pr);
		}

		Long totalCount = this.proxyDao.findRecordsCount(countHql);
		pageQueryResult.setTotalCount(totalCount);

		pageQueryResult.setResults(results);

		return pageQueryResult;
	}
}
